package com.yedam.java.ch0601;

public class CarExample {

	public static void main(String[] args) {
		// 클래스는 일종의 타입임! 타입처럼 쓰면 됨
		
		// Car라는 클래스를 이용해 인스턴스 만들기
		// 클래스이름 변수이름 = new Car(); (외부에서 값을 주는건 불가능함)
		Car car1 = new Car();
		
		// "자동차가 출하되었습니다"가 출력됨
		// 이 프린트는 Car라는 클래스의 '생성자'에 있음.
		// new는 생성자를 호출하는 것!
		
		// 속성은 굉장히 많이 들고 있을 수 있음! 그냥 car1이라고 쓰면 안 됨
		// car1.내부의 속성값을 지정해줘야 함
		System.out.println("최대 스피드: " + car1.maxSpeed);
		System.out.println("색깔: " + car1.color);
		
		// 메소드 실행
		car1.run();
		
		System.out.println(); // 구분선
		
		// 새로운 인스턴스 참조하기
		Car car2 = new Car();
		System.out.println("최대 스피드: " + car2.maxSpeed);
		System.out.println("색깔: " + car2.color);
		car2.run();

		
		// car1과 car2는 출력되는 결과가 똑같은데 같은 객체를 참고하고 있는걸까? 검사해보자
		if(car1 == car2) {
			System.out.println("car1과 car2는 동일한 객체를 참조합니다.");
		} else {
			System.out.println("car1과 car2는 서로 다른 객체를 참조합니다.");
		}
		// 결과: 서로 다른 객체를 참조함!
		// car1, car2는 서로 다른 객체를 참조하는건 맞지만, 내부에 동일한 값을 들고있음
		// 같은 클래스를 기반으로 만들어 진 건 맞는데 서로 다른 존재라는 뜻임!
		// (같은 티볼리 설계도로 만들었지만 티볼리1, 티볼리2라는 다른 완성품이라는 것)
		// new 연산자는 무조건 새로운 인스턴스를 만들어 냄!
		
		
		// 메소드: 설계도가 모여있는 공간
		// 한 프로젝트에서 class를 만들면 모두 메소드에 담긴다고 보면 됨
		// 실제 사용유무와는 관계없음
		
		// 스택에서 new 연산자를 사용해 car1을 생성하면, 자바는 메소드를 먼저 확인함.
		// 메소드에 Car가 있는지 확인하고, 있다면 생성자를 호출함 => 힙 영역에 객체를 만든다는 뜻
		// 힙 영역에 만들어진 객체의 주소를 스택 영역의 car1과 연결해줌 (메소드에 있는 class에서 바로 스택 영역으로 연결하는게 아님)
		// car1, car2라는 인스턴스의 객체의 모양은 같지만 각각 주소가 따로 있음!(일란성 쌍둥이라고 생각하면 됨)
		// car1의 color를 blue로 지정하면 car1 하나만 변경됨!, car2는 기존값 그대로.
		// (class에 있는 color를 건드는게 아님!!!!!!!!!)
		// 티볼리1은 파랑색, 티볼리2는 빨간색인거임. 인스턴스가 생성된 후는 각각 개별의 것이라고 보면 됨.
		// 태어나는 순간은 부모의 값을 가져가겠지만, 살아가면서 접하는 것들에 따라 전혀 다르게 성장할 수 있다는 것!
		
	}

}
